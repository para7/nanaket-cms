# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# Nanaket CMS

Content Management System built with Go and PostgreSQL using a schema-first database approach.

## Architecture Overview

### Tech Stack
- **Language**: Go 1.25.3
- **Database**: PostgreSQL 18 (Docker)
- **Schema Migration**: psqldef (declarative schema management)
- **SQL Code Generation**: sqlc (type-safe Go code from SQL)
- **Database Driver**: pgx/v5 (PostgreSQL driver)

### Project Structure
```
cmd/api/main.go           # Application entry point
db/
  schema/schema.sql       # Database schema (managed by psqldef)
  queries/*.sql           # SQL queries with annotations for sqlc
internal/db/              # Generated Go code from sqlc (do not edit manually)
```

### Database-First Architecture

This project follows a schema-first approach:
1. **Schema Definition**: Define tables in `db/schema/schema.sql`
2. **Migration**: Apply schema using psqldef (declarative, idempotent)
3. **Query Definition**: Write SQL queries in `db/queries/*.sql` with sqlc annotations
4. **Code Generation**: Run sqlc to generate type-safe Go code in `internal/db/`

The generated code in `internal/db/` includes:
- `models.go`: Go structs matching database tables
- `querier.go`: Interface for all database operations
- `*.sql.go`: Type-safe query implementations

## Development Commands

### Database Management
- `make db-up` - Start PostgreSQL container
- `make db-down` - Stop PostgreSQL container
- `make db-migrate` - Apply schema changes from `db/schema/schema.sql`
- `make db-generate` - Generate Go code from SQL queries using sqlc
- `make db-reset` - Wipe database and start fresh (removes volumes)
- `make dev` - Setup complete dev environment (db-up + db-migrate + db-generate)

### Running the Application
- `make run` - Start the API server (requires `make db-up` first)

### Database Configuration
Default connection (can override with DATABASE_URL env var):
```
postgres://nanaket:nanaket@localhost:5432/nanaket_cms?sslmode=disable
```

## Development Workflow

### Adding New Tables or Columns
1. Edit `db/schema/schema.sql` (psqldef uses declarative syntax)
2. Run `make db-migrate` to apply changes
3. If adding queries, create/edit `db/queries/*.sql`
4. Run `make db-generate` to regenerate Go code

### Adding New Queries
1. Create or edit files in `db/queries/` with sqlc annotations:
   ```sql
   -- name: GetUser :one
   SELECT * FROM users WHERE id = $1 LIMIT 1;

   -- name: ListUsers :many
   SELECT * FROM users ORDER BY id;
   ```
2. Run `make db-generate` to generate Go code
3. Use generated code: `queries.GetUser(ctx, userID)`

### sqlc Configuration
The `sqlc.yaml` configures:
- Output package: `db` in `internal/db/`
- JSON tags, interfaces, and null type handling
- pgx/v5 as the SQL package

## Project Context

### Paths
- Steering: `.kiro/steering/`
- Specs: `.kiro/specs/`
- Commands: `.claude/commands/`

### Steering vs Specification

**Steering** (`.kiro/steering/`) - Guide AI with project-wide rules and context
**Specs** (`.kiro/specs/`) - Formalize development process for individual features

### Active Specifications
- **blog-cms**: Blog article management CMS (initialized)
- Use `/kiro:spec-status [feature-name]` to check progress

## Development Guidelines
- Think in English, generate responses in English
- Never manually edit files in `internal/db/` - they are generated by sqlc
- Always run `make db-generate` after modifying SQL queries or schema

## Workflow

### Phase 0: Steering (Optional)
`/kiro:steering` - Create/update steering documents
`/kiro:steering-custom` - Create custom steering for specialized contexts

Note: Optional for new features or small additions. You can proceed directly to spec-init.

### Phase 1: Specification Creation
1. `/kiro:spec-init [detailed description]` - Initialize spec with detailed project description
2. `/kiro:spec-requirements [feature]` - Generate requirements document
3. `/kiro:spec-design [feature]` - Interactive: "Have you reviewed requirements.md? [y/N]"
4. `/kiro:spec-tasks [feature]` - Interactive: Confirms both requirements and design review

### Phase 2: Progress Tracking
`/kiro:spec-status [feature]` - Check current progress and phases

## Development Rules
1. **Consider steering**: Run `/kiro:steering` before major development (optional for new features)
2. **Follow 3-phase approval workflow**: Requirements → Design → Tasks → Implementation
3. **Approval required**: Each phase requires human review (interactive prompt or manual)
4. **No skipping phases**: Design requires approved requirements; Tasks require approved design
5. **Update task status**: Mark tasks as completed when working on them
6. **Keep steering current**: Run `/kiro:steering` after significant changes
7. **Check spec compliance**: Use `/kiro:spec-status` to verify alignment

## Steering Configuration

### Current Steering Files
Managed by `/kiro:steering` command. Updates here reflect command changes.

### Active Steering Files
- `product.md`: Always included - Product context and business objectives
- `tech.md`: Always included - Technology stack and architectural decisions
- `structure.md`: Always included - File organization and code patterns

### Custom Steering Files
<!-- Added by /kiro:steering-custom command -->
<!-- Format:
- `filename.md`: Mode - Pattern(s) - Description
  Mode: Always|Conditional|Manual
  Pattern: File patterns for Conditional mode
-->

### Inclusion Modes
- **Always**: Loaded in every interaction (default)
- **Conditional**: Loaded for specific file patterns (e.g., "*.test.js")
- **Manual**: Reference with `@filename.md` syntax

